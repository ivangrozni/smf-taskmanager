Taskmanager:
============

tables: - Tasks
	- Projects

 Tasks: 01 id_prim !     INT       AUTO_INC
 	02 id_sec  	 INT                   # DEFAULT id_sek=id_prim - iste zadolzitve, ki jih opravljajo razlicni ljudje imajo enak id_sec
	03 id_proj	 INT
	04 id_author	 INT
	05 t_name	 CHAR(50)
	06 t_desc	 CHAR(250)
	07 in_date	 TIMESTAMP
	08 deadline	 DATETIME
	09 priority	 INT

	10 state	 INT	DEFAULT=0

	11 start_date	 DATETIME
	12 id_member	 INT
	
	13 end_date	DATETIME
	14 end_comment	CHAR(250)

 Projects: 01 id_proj	   INT
 	   02 p_name	   CHAR(50)
	   03 p_desc	   CHAR(250)
	   04 id_coord	   INT			# koordinator
	   05 start	   DATE
	   (06 deadline	   DATE)		# ve se, kdaj se bo zaključil projekt
	   07 end	   DATE
	   (08 end_comment  CHAR(250))          # tega ubistvu ne rabimo - debata o projektih bo tekla v več nitkah

Actions: - add_project
	 - add_task
	 - acc_task
	 - end_task

Views: - show_free_tasks
       - show_my_tasks
       - show_proj
       - show_proj_tasks
       - show_timeline               # Vprasanje kaj bo


######
AKCIJE
######


 add_project
 ===========

 INSERT INTO Projects (p_name, p_desc, id_coord, start, end) VALUES ( "ime", "opis", id_uporobnika, datum_zacetka, rok);

 # Ustvari nov projekt!

 add_task
 ========

 INSERT INTO Tasks (id_proj, id_author*, t_name, t_desc, deadline, priority) VALUES ( NULL ali proj, avtor, ime, opis, rok, pomembnost);

 # avtor je določen z uporabnikom, ki vnaša, in_date pa je timestamp. Stanje je DEFAULT = 0, tako da je ok.
 # Ob ustbvaritvi se ne zapolnejo mesta start_date, id_member, end_date, end_comment. start_date in id_member se zapolnita ob 
 # sprejetju naloge, zadnja dva pa ob zaključku. Izpolni jih oseba, ki nalogo razrešuje.
       
 acc_task
 ========

 SELECT state FROM Tasks WHERE id_prim = X;      # id_prim je določen glede na izbrano (kliknjeni gumb accept) zadolžitev.

 1) IF state == 0:

    UPDATE Tasks SET start_date = ...
    	   	     id_member = Y        # Y določen z uporabnikom, ki je izbral zadolzitev
		     state = 1
        WHERE id_prim = X;                # X določen z zadolžitvijo, ki je izbrana

 2) ELSE IF state == 1:
   
    INSERT INTO Tasks (id_sec*, id_proj*, id_author*, t_name*, t_desc*, in_date*, deadline*, priority*, state, id_member, start_date) VALUES
        ( ... );
    # id_sec = id_sec kliknjene zadolžitve, * se skopira, state = 1, id_member - kdor je kliknil, start_date = timestamp

 3) ELSE: Zadolžitev je zaključena

 # Sprejetje naloge. Če naloge še ne dela nihče, potem ji spremenimo stanje (state), hkrati pa dodamo start_date in id_member - začetek dela in
 # ime uporabnika, ki bo nalogo razrešil.

 # Če se Iskraš prijavlja k nalogi, ki jo nekdo že opravlja - zahtevnejša naloga, ki potrebuje več ljudi, se ustvari nova naloga, prepišejo se
 # se vrednosti iz prve naloge (id_sec, projekt, avtor, ime, opis, datum_vnosa, rok, pomembnost in stanje), doda pa se nov datum začetka
 # in uporabnika, ki nalogo izvršuje.

 # Torej, koordinator projekta ima možnost, da dodaja uporabnikom določa naloge (da iskraše javlja na naloge:).

 end_task
 ========

 UPDATE Tasks SET state = 2, 3, 4...
 	      	  end_date = timestamp
		  end_comment = "komentar"
      WHERE id_prim == X AND id_member == Y;                 # X Določen s klikom, Y določen z uporabnikom (ne moreš zaključiti taska koga drugega)

 # Zaključek naloge. Izpolni uporabik, ki je zadolžitev delal. Izpolni samo komentar, datum zaključka se izpolni sam.


#####
VIEWS
#####

 show_all_tasks
 ==============

 SELECT (t_name, p_name, deadline, state, priority, author) FROM Tasks T1
    INNER JOIN Projects T2 ON T1.id_proj = T2.id_proj
    INNER JOIN Members T3 IN T1.id_author = T3.id_member
    ORDER BY deadline ASC
    GROUP BY id_sec;

 # Prikaže vse zadolžitve (ne glede na stanje). Istih zadolžitev z razlićnimi izvrševalci ne prikaže. 
 # Zraven je še gumbek za podrobnosti naloge - show_task() funkcija.

 show_free_tasks
 ===============

 SELECT (t_name, p_name, deadline, state, priority, author) FROM Tasks T1 
     INNER JOIN Projects T2 ON T1.id_proj = T2.id_proj
     INNER JOIN Members T3 IN T1.id_author = T3.id_member
     	   WHERE state = 0 OR state = 1
	   GROUP BY id_sec;

 # Tukaj še ni potrebe, da veš kdo task izvaja. To izveš v podrobnostih zadolžitve/taska.
 # Če klikneš na task, se morajo izpisati podrobnosti za samo ta task.
 # Zraven vseh so gumbki za sprejetje nadloge, ki te najprej pripeljejo na show_task,
 # torej podrobnosti naloge.

 # Delujoč Querry:
 SELECT t_name AS zadolzitev, deadline AS rok, state AS stanje, priority AS pomembnost, name AS avtor, p_name AS projekt FROM Tasks T1 INNER JOIN Members T3 ON T1.id_author=T3.id_member INNER JOIN Projects T2 ON T1.id_proj=T2.id_proj;

 show_task
 =========

 1) IF state < 2:

 SELECT (t_name, p_name, t_desc, deadline, state, author) FROM Tasks
     WHERE id_prim = X;                   # X določen glede na to, kateri task klikneš

 SELECT COUNT(*) FROM Tasks WHERE id_sec = X;   # presteje koliko uporabnikov dela na nekem tasku
 		      	    	  	   	# Tole se more izpisat k prejšnjemu querry-ju

 SELECT member FROM Tasks WHERE id_sec = X;     # Izpiše ljudi, ki izvajajo zadolžitev

  # nr_members mora sešteti zadolžitve z enakim id_sec

 2) ELSE IF state >= 2:

 SELECT (t_name, p_name, t_desc, start_date, deadline, state, author, end_date, end_comment) FROM Tasks
     WHERE id_prim = X;                   # X določen glede na to, kateri task klikneš

 # Prikaže posamezen podrobnosti izbrane zadolžitve. Če je stanje 0 ali 1, mora biti zraven gumbek za sprejetje naloge.
 # acc_task() funkcija. Argument acc_task(id_prim) je primarni id zadolžitve. 

 show_my_tasks
 =============

 SELECT (t_name, p_name, deadline) FROM Tasks T1
     INNER JOIN Projects T2 ON T1.id_proj = T2.id_proj
     	   WHERE id_member = X;                        # X določen z uporabnikom, SORT BY ?

 # Prikaže zadolžitve posameznega uporabnika.
 # Pri tistih s stanjem 0 ali 1 mora biti zraven še gumb za zaključek naloge.

 show_proj
 =========

 SELECT (p_name, start_date, koordinator, deadline) FROM Projects T1
 	INNER JOIN Members T2 ON T1.coord = T2.member;

 # V tabeli mora biti Project kot link. Klik nanj odpre okno, ki pokaže njegov description in zadolžitve tega projekta.

 show_proj_tasks
 ===============
 
 SELECT (t_name, deadline, priority, state, author) FROM Tasks
    INNER JOIN Members T3 IN T1.id_author = T3.id_member
       GROUP BY id_sec;

 # Prikaže zadolžitve posameznega projekta.
 # Spet klik na task pomeni execute show_task();


____________________________________________________

  created_on TIMESTAMP DEFAULT 0,
  changed_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP
               ON UPDATE CURRENT_TIMESTAMP
